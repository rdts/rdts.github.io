<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rover3D</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
    
    <style>
    a:link {
      color: #adf;
    }
    a:visited {
      color: #adf;
    }
    a:hover {
      color: #4ff;
    }
    
    #annotation {
      position: absolute;
      padding: 5px 10px;
      color: #ddd;
      background: rgba(0, 0, 0, 0.6);
      border-radius: .5em;
      font-size: 12px;
      line-height: 1.2;
      transition: opacity .5s;
    }

    #status_container {
      text-shadow: 0px 0px 8px rgba(255, 255, 255, 0.1);
      color: orange;
      margin: 5px;
      position: absolute;
      right: 0px;
      z-index: 98;
      bottom: 0px;
      //opacity: 0.5;
      font-size: 12px;
    }
    
    #webgl {
      position: fixed;
      width: 100%; /* Full width (cover the whole page) */
      height: 100%; /* Full height (cover the whole page) */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -1;
    }
    
    #overlay {
      position: fixed; /* Sit on top of the page content */
      display: none; /* Hidden by default */
      width: 100%; /* Full width (cover the whole page) */
      height: 100%; /* Full height (cover the whole page) */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.8); /* Black background with opacity */
      z-index: 2; /* Specify a stack order in case you're using a different order for other elements */
      cursor: pointer; /* Add a pointer on hover */
    }
    .astext {
      background:none;
      border:none;
      margin: 5px;
      padding:0;
      cursor: pointer;
      outline:none;
      user-select: none;
      -webkit-user-select: none; /* Safari */        
      -moz-user-select: none; /* Firefox */
    }
    
    #info_button {
      z-index: 99;
      font-family: Monospace;
      text-shadow: 0px 0px 8px #3DF;
      color: #3DF;
      position: absolute;
      left: 0px;
      top: 0px;
    }
    
    #info {
      text-align: left;
      position: absolute;
      width: 75%;
      height: 75%;
      top: 50%;
      left: 50%;
      font-size: 14px;
      color: #ccc;
      transform: translate(-50%,-50%);
      -ms-transform: translate(-50%,-50%);
    }
    
    emph {
      font-weight: bold;
      color: white;
    }
    
    #compassInset {
      width: 60px;
      height: 60px;
      background-color: transparent; /* or transparent; will show through only if renderer alpha: true */
      border: none; /* or none; */
      margin: 0;
      padding: 0px;
      position: absolute;
      left: 0px;
      bottom: 0px;
      z-index: 100;
    }
    
    </style>
    
    
	</head>

	<body>

    <!-- Status Indicator -->
    <div class="annotation" id="status_container">Initializing</div>  

    <!-- Make Acknowledgments Panel -->
    <button class="astext" id="info_button" onclick="overlayOn()">About</button>
    <div id="overlay" onclick="overlayOff()">
      <div id="info">
        <h1>Rover 3D</h1>
        R. Kinnett, 2021
        <br/>
        <hr/>
        <h3>Controls:</h3>
        <li>Left button: rotate, center wheel: zoom, right button: pan</li>
        <li>Double-click:  center view over selected position</li>
        <li>Key "d":  <emph>d</emph>rop rover at cursor</li>
        <li>Key "r":  center view over <emph>r</emph>over</li>
        <br/>
        <hr/>
        <h3>Acknowledgments:</h3>
        <li>
          Base terrain map derived from USGS <a href="https://astrogeology.usgs.gov/search/map/Mars/Mars2020/JEZ_hirise_soc_006_DTM_MOLAtopography_DeltaGeoid_1m_Eqc_latTs0_lon0_blend40">"Mars 2020 Terrain Relative Navigation HiRISE DTM Mosaic"</a> via Mars Reconnaissance Orbiter MOLA (NASA/JPL/GSFC/USGS) and HiRISE (NASA/JPL/University of Arizona)
        </li>
        <li>
          Colorized via <a href="https://www.flickr.com/photos/132160802@N06/50905666446/">Jezero Crater</a> mosaic by Justin Cowart with source images from MRO CTX (NASA/JPL/MSSS) and CRISM (NASA/JPL/JHUAPL), and Mars Express HRSC (ESA/DLR/FU Berlin)
        </li>
        <li>
          Perseverance model courtesy <a href="https://mars.nasa.gov/resources/25042/mars-perseverance-rover-3d-model/" target="_blank" rel="noopener">NASA/JPL</a> (heavily modified by R. Kinnett)
        </li>
        <br />
      </div>
    </div>

    <!-- Webgl container for Mars scene -->
    <div id="webgl"></div>

    <!-- Compass inset -->
		<div id="compassInset"></div>


    <!-- USEFUL REFERENCES:
      https://www-robotics.jpl.nasa.gov/publications/Mark_Maimone/fulltext.pdf
      https://pds-imaging.jpl.nasa.gov/documentation/MSL_COORDINATE_FRAMES.PDF 
    -->

    <script>
      function overlayOn() {  document.getElementById("overlay").style.display = "block"; }
      function overlayOff() { document.getElementById("overlay").style.display = "none";  }
    </script>

    <script src="js/dat.gui.min.js"></script>
    <script src="js/decode-tiff.min.js"></script>


		<script type="module">
      import * as THREE from './js/three.module.js';
			import { OrbitControls, MapControls } from './js/OrbitControls.js';
			import { GLTFLoader } from './js/GLTFLoader.js';
			import { Sky } from './js/Sky.js';
      import { Lensflare, LensflareElement } from './js/LensFlare.js';
      import { Reflector } from './js/Reflector.js';
			import { VertexNormalsHelper } from './js/VertexNormalsHelper.js';
      const { decode } = window.decodeTiff;
      window.THREE = THREE;

    
			let camera, scene, renderer, controls;
      let rover, diffuselight, selected, roverNavCoordFrameAxes, terrain, terrainWireframe;
      let mirrorCamera, rmiMirror, insetWidth, insetHeight, mirrorMaterial, mirror, mirrorRendertTarget;
      let compassInsetContainer, compassInsetScene, compassInsetRenderer, compassInsetCamera, compass;
			let sky, uniforms;
      let ruler;
      let deg2rad = Math.PI/180;
      let rad2deg = 180/Math.PI;

      let vecs = {};
      window.vecs = vecs;


      let parts = {};
      window.parts = parts;
      
      let coordaxes = {};
      
      window.render = render;
    
      let sun = {
        pos:  new THREE.Vector3(),
        directionalLight:  null,
      }
      window.sun = sun;
    
      let jointGroupNames = ["arm", "rsm", "hga", "mob"];
      let jointGroupLongNames = {arm: "Robotic Arm", rsm: "Remote Sensing Mast", hga: "High-Gain Antenna", mob: "Suspension"};
    
      let joints = {
        arm: {
          az:     {name: "Azimuth",   model_obj_name: "arm_az",     axis: "z",  dir: 1,  angle: 0.1,  min:-180,  max:180},
          el:     {name: "Elevation", model_obj_name: "arm_el",     axis: "y",  dir:-1,  angle: 0.1,  min:-180,  max:180},
          elbow:  {name: "Elbow",     model_obj_name: "arm_elbow",  axis: "y",  dir:-1,  angle: 0.1,  min:-180,  max:180},
          wrist:  {name: "Wrist",     model_obj_name: "arm_wrist",  axis: "y",  dir:-1,  angle: 0.1,  min:0,     max:360},
          turret: {name: "Turret",    model_obj_name: "arm_turret", axis: "z",  dir: 1,  angle: 0.1,  min:-10,   max:370},
        },
        
        rsm: {
          az:     {name: "Azimuth",   model_obj_name: "rsm_az",     axis: "z",  dir: 1,  angle: 0.1,  min:-185,  max:185 },
          el:     {name: "Elevation", model_obj_name: "rsm_el",     axis: "y",  dir: 1,  angle: 0.1,  min:-87,   max:91 },
        },

        hga: {
          az:     {name: "Azimuth",   model_obj_name: "hga_az",     axis: "z",  dir: 1,  angle: 0.1,  min:-185,  max:185 },
          el:     {name: "Elevation", model_obj_name: "hga_el",     axis: "y",  dir: 1,  angle: 0.1,  min:0,     max:180 },
        },
        
        mob: {
          steer_rf:  {name: "Steer Right-Front",   model_obj_name: "suspension_strut_RF",     axis: "z",  dir:-1,  angle: 0.1,  min:-90,  max:90 },
          steer_rr:  {name: "Steer Right-Rear",    model_obj_name: "suspension_strut_RR",     axis: "z",  dir:-1,  angle: 0.1,  min:-90,  max:90 },
          steer_lf:  {name: "Steer Left-Front",    model_obj_name: "suspension_strut_LF",     axis: "z",  dir:-1,  angle: 0.1,  min:-90,  max:90 },
          steer_lr:  {name: "Steer Left-Rear",     model_obj_name: "suspension_strut_LR",     axis: "z",  dir:-1,  angle: 0.1,  min:-90,  max:90 },
          diff:      {name: "Rocker Differential", model_obj_name: "suspension_diff",         axis: "z",  dir: 1,  angle: 0.1,  min:-8,   max:8  },
          bogie_left: {name: "Bogie Left",         model_obj_name: "suspension_bogie_left",   axis: "y",  dir: 1,  angle: 0.1,  min:-40,   max:40  },
          bogie_right: {name: "Bogie Right",       model_obj_name: "suspension_bogie_right",  axis: "y",  dir: 1,  angle: 0.1,  min:-40,   max:40  },
        },
      };
      window.joints = joints;
      
      
      // factor the joint names:
      let jointNames = {arm:[], rsm:[], hga:[], mob:[]};
      window.jointNames = jointNames;
      jointGroupNames.forEach(function(jointGroupName){
        for(var jointName in joints[jointGroupName]) { 
          //console.log(jointNames);
          jointNames[jointGroupName].push(jointName);
        }
      });
      
      // Define canonical poses:
      let poses = {
        arm: {
          STOW:          [ 1.5721, -0.2778, -2.8163,  3.1211,  1.5708],
          READY_OUT:     [ 0.0000, -1.5708,  1.5708,  0.0000,  3.1416],
          READY_IN:      [-3.1416, -1.5708, -1.5708, -3.1416,  0.0000],
          DECK_READY:    [-0.1586, -1.1120, -1.2482,  0.7949,  0.0458],
          BIT_BOX:       [-1.4525, -1.9292, -1.3844,  0.1139,  1.2716],
          DRILL_SIEUWU:  [-2.474, -2.3378, -2.1335, 2.9149, 6.281],
          DRILL_SOEUWU:  [0.38626, -0.70338, 2.225, 3.1873, -0.0405],
          DRILL_SOEUWD:  [0.38626, -0.43097, 2.0207, 0, 3.118],
          PIXL_SIEUWU:   [-2.474, -2.3378, -2.4059, 3.1873, 4.6995],
          PIXL_SOEUWD:   [0.045751, -0.22666, 1.8164, 0, 1.6084],
          ZERO:          [0, 0, 0, 0, 0],
        },
        rsm: {
          STOW:          [-2.09, -1],
          STRAIGHT:      [0, 0],
          WORKSPACE:     [-0.5, -0.8],
        },
        hga: {
          STOW:          [-1.05, 1.5708],
          READY:         [0, 0.5],
        },
        mob: {
          STRAIGHT:       [0, 0, 0, 0,    0, 0, 0, 0, 0],
          TURN_IN_PLACE:  [0.785, -0.785, -0.785, 0.785,    0, 0, 0, 0, 0],
          TURN_RIGHT:     [-0.785, 0.785, -0.785, 0.785,    0, 0, 0, 0, 0],
          TURN_LEFT:      [0.785, -0.785, 0.785, -0.785,    0, 0, 0, 0, 0],
        },
      };
            
      // factor the poses:
      let poseNames = {arm:[], rsm:[], hga:[], mob:[]};
      jointGroupNames.forEach(function(jointGroupName){
        for(var poseName in poses[jointGroupName]) { poseNames[jointGroupName].push(poseName); }
      });

      let options = {
        tools: {
          ruler: false,
        },
        scene: {
          surfaceColor:  0xc3a17f,
          showHaze:   true,
          fogDist:    5000,
          showWireframe:  false,
          wireframeColor: 0x090909,
          showCompass:  true,
        },
        pose: {
          arm: "STOW",
          hga: "STOW",
          rsm: "STRAIGHT",
          mob: "STRAIGHT",
        },
        attitude: {
          roll: 0,
          pitch: 0,
          yaw: 0,
          height: -0.01,
          showRnavCoordFrame: false,
        },
        sky: {
					turbidity: 4,
					rayleigh: 0.025,
					mieCoefficient: 0.001,
					mieDirectionalG: 0.7,
          diffuseLightColor:     0xf5b97c,
          initialDiffuseLightIntensity: 0.6,
          minDiffuseLightIntensity: 0.05,
        },
        sun: {
          az: -90, 
          el: 30, 
          dist: 4000, 
          x:0, 
          y:0, 
          z:0, 
          lightColor:      0xffffff,
          initialLightIntensity:  0.81,
          minLightFraction: 0.01,  //light intensity with sun at zero el
          maxElQuadraticLight: 20, //deg below which light falls off quadratically
        }
      };
      window.options = options;
        
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var clicked = new THREE.Vector2();
      
      startLoadingManager();
			init();
			render();

			function init() {

        const container = document.getElementById('webgl');

				renderer = new THREE.WebGLRenderer( { antialias: true } )
        renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true; 
        //renderer.shadowMapSoft = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				//renderer.autoClear = false;
        renderer.alpha = false;
        //renderer.preserveDrawingBuffer = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.physicallyCorrectLights = true;
        renderer.toneMappingExposure = 0.65; 
        window.renderer = renderer;
				container.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 8000 );
        camera.up.set( 0, 0, -1 );
        camera.lookAt(0,0,-1);
				//camera.position.set( 3.6, -0.1, -0.65 );
        //camera.position.set( 3.6, 0, -0.65 );
        camera.position.set( 5, 0, -1.4 );
        window.camera = camera;
                
                
        // Make Controls:
				controls = new MapControls( camera, renderer.domElement );
				//const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
        //controls.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
        //controls.mouseButtons = { ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
        controls.mouseButtons = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
        controls.enableKeys = true;
        //controls.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
				controls.minDistance = 0.1;
				controls.maxDistance = 8000;
        controls.screenSpacePanning = true;
        controls.enableDamping = false;
				controls.target.set( 0, 0, -1 );
        controls.addEventListener('change', render);
        window.controls = controls;

        // make compass inset:
        makeCompass();
        compass.visible = options["scene"].showCompass;
                
				scene = new THREE.Scene();
        window.scene = scene;
        scene.fog = new THREE.Fog(0xc3a17f, 0.1, options["scene"].showHaze ? options["scene"].fogDist : 0 );
        //scene.background = new THREE.Color( options.skyColor );

        // Make RMI mirror:
        // to-do:  vertically invert the reflection
        mirrorCamera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 0.1, 1000 );
        window.mirrorCamera = mirrorCamera;
        mirrorCamera.rotation.y = -1*Math.PI/2;
        scene.add( mirrorCamera );
        //const helper = new THREE.CameraHelper( mirrorCamera );  //handy for debugging
        //scene.add( helper );
        var mirrorGeom = new THREE.CircleGeometry( 0.07, 32 );
				mirror = new Reflector( mirrorGeom, {
					clipBias: 0.003,
					textureWidth: window.innerWidth * window.devicePixelRatio,
					textureHeight: window.innerHeight * window.devicePixelRatio,
					color: 0xaaaa66,
				} );
        mirror.rotation.y = -1*Math.PI/2;
        

				// Add Sky
				sky = new Sky();
				sky.scale.setScalar( 45000 );
        uniforms = sky.material.uniforms;
        uniforms.turbidity.value        = options.sky.turbidity;
        uniforms.rayleigh.value         = options.sky.rayleigh;
        uniforms.mieCoefficient.value   = options.sky.mieCoefficient;
        uniforms.mieDirectionalG.value  = options.sky.mieDirectionalG;
        uniforms.up.value               = new THREE.Vector3(0, 0, -1);
				scene.add( sky );

        // Make lighting:
        diffuselight = new THREE.AmbientLight( options["sky"].diffuseLightColor );
        diffuselight.intensity = options["sky"].initialDiffuseLightIntensity;
        //diffuselight = new THREE.HemisphereLight( options["sky"].diffuseLightColor, options.surfaceColor, options["sky"].initialDiffuseLightIntensity );
        scene.add( diffuselight );
        
        //sun.light = new THREE.PointLight( options["sun"].lightColor, options["sun"].initialLightIntensity, 0, 0.001);
        sun.light = new THREE.DirectionalLight( options["sun"].lightColor, options["sun"].initialLightIntensity);
        sun.light.castShadow = true;
        sun.light.shadow.camera.near = 100;
        sun.light.shadow.camera.far = 12000;
        sun.light.shadow.mapSize.width = 2048;
        sun.light.shadow.mapSize.height = 2048;
        scene.add( sun.light );
        //Create a helper for the shadow camera
        //const helper = new THREE.CameraHelper( sun.light.shadow.camera );
        //scene.add( helper );
        sun.light.extinctionCoeffs = [
          (options["sun"].minLightFraction-1)/(options["sun"].maxElQuadraticLight*options["sun"].maxElQuadraticLight),
          -2*(options["sun"].minLightFraction-1)/options["sun"].maxElQuadraticLight,
          options["sun"].minLightFraction
        ];
        
        placeSun();
        
        // Make lens flares:
        const textureLoader = new THREE.TextureLoader();
        const textureFlare0 = textureLoader.load( "./images/lensflare0.png" );
        const textureFlare1 = textureLoader.load( "./images/lensflare2.png" );
        const textureFlare2 = textureLoader.load( "./images/lensflare3.png" );
        const lensflare = new Lensflare();
        //lensflare.addElement( new LensflareElement( textureFlare0, 88, 0 ) );
        //lensflare.addElement( new LensflareElement( textureFlare1, 120, 0 ) );
        lensflare.addElement( new LensflareElement( textureFlare2, 80,  0 ) );
        lensflare.addElement( new LensflareElement( textureFlare2, 200, 0.1 ) );
        lensflare.addElement( new LensflareElement( textureFlare2, 120, 0.15 ) );
        //sun.light.add( lensflare );
        
        // Make Ground plane:
        const geometry = new THREE.PlaneGeometry( 300, 300, 32 );
        const groundMaterial = new THREE.MeshPhongMaterial({ color: options["scene"].surfaceColor, fog: false  });
        const groundPlane = new THREE.Mesh( geometry, groundMaterial );
        groundPlane.name = "ground";
        groundPlane.rotation.x = -1*Math.PI/2;
        groundPlane.receiveShadow = true;
        //scene.add( groundPlane );
                
        const vscale = 0.02;  //m/dn, vertical scale of terrain height map
        const hscale = 8;    //m/px, horizontal grid spacing of terrain height map
        makeTerrain({
          urlHeightMap: 'images/Jezero_MOLA_16bit_v2cm_h8m.tif',  // must be 16-bit grayscale tif
          //urlTextureMap: 'images/JEZ_hirise_soc_007_orthoMosaic_25cm_Ortho_blend120_crop8192m_rescale_2m_CRISM_color.jpg',
          urlTextureMap: 'images/JEZ_hirise_soc_007_orthoMosaic_25cm_Ortho_blend120_crop32768_rescale1m_color_routemap.jpg',
          hscale: hscale,    // m/px
          vscale: vscale,  // m/px
          color:  options["scene"].surfaceColor,
          onload: function(){
            console.log("loaded terrain");
            terrain.rotation.x = -1*Math.PI;
            terrain.rotation.z = -1*Math.PI/2;
            terrain.position.set(875, -1165, 240.14);
            terrain.geometry.computeFaceNormals();
            terrain.geometry.computeVertexNormals();
            scene.add(terrain);            
            //var vnh = new VertexNormalsHelper( terrain, 1 );
            //scene.add( vnh );

            terrainWireframe.visible = options["scene"].showWireframe;
                        
            render();
            controls.update();
          }
        });

        // Make coordinate frame axes:
        roverNavCoordFrameAxes = createCoordAxes(scene, 0.5, "rnav");
        roverNavCoordFrameAxes.visible = options["attitude"].showRnavCoordFrame;
        
        // Make ruler:
        let rulerGroup = new THREE.Group();
        ruler = {
          pos0: new THREE.Vector3(0,0,0),
          pos1: new THREE.Vector3(0,0,0),
          pin0: makePin(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1), 0.25, 0.01, 0x00ffff, function(pin){rulerGroup.add(pin)}),
          pin1: makePin(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1), 0.25, 0.01, 0x00ffff, function(pin){rulerGroup.add(pin)}),
          line: new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]), 
            new THREE.LineBasicMaterial({color: 0x66ddff, depthTest: false}),
          ),
        }        
        ruler.pin0.visible = false;
        ruler.pin1.visible = false;
        ruler.line.visible = false;
        ruler.line.frustumCulled = false;
        rulerGroup.add(ruler.line);
        scene.add(rulerGroup);
        window.ruler = ruler;

        //var armUnstowFcnWrapper = { add:function(){ armGoToPose("READY_OUT") }};
        //var armStowFcnWrapper = { add:function(){ armGoToPose("STOW") }};

        var gui = new dat.GUI();
        window.gui = gui;
        let folder = {};
  
        folder["tools"] = gui.addFolder('Tools');
        folder["tools"].add(options["tools"], 'ruler').name('Ruler').onChange(toggleRuler);
        
        folder["scene"] = gui.addFolder('Scene');
        folder["scene"].add(options["sun"], 'az', -179.9, 180.1).listen().name("Sun azimuth").onChange(placeSun);
        folder["scene"].add(options["sun"], 'el', -0.5, 180.5).listen().name("Sun elevation").onChange(placeSun);
        folder["scene"].add(sun.light, 'intensity', 0.001, 0.999).listen().name("Sunlight intensity").onChange(render);
        folder["scene"].addColor(options["sun"],'lightColor').name("Sunlight color").onChange(function(val){sun.light.color.set(val); render()});
        folder["scene"].add(diffuselight, 'intensity', 0.001, 0.999).listen().name("Diffuse light").onChange(render);
        folder["scene"].addColor(options["sky"],'diffuseLightColor').name("Diffuse light color").onChange(function(val){diffuselight.color.set(val); render()});
        //folder["scene"].addColor(options["scene"],'surfaceColor').name("Surface color").onChange(function(val){groundPlane.material.color.set(val); render()});
        folder["scene"].addColor(options["scene"],'surfaceColor').name("Surface color").onChange(function(val){terrain.material.color.set(val); render()});
        folder["scene"].add(options["scene"], 'showHaze').listen().name("Haze").onChange(function(val){
          scene.fog.far = val ? options["scene"].fogDist : 0; 
          render();
        });
        folder["scene"].add(options["scene"], 'showWireframe').listen().name("Grid (" + hscale + "m)").onChange(function(val){terrainWireframe.visible = val; render()});
        folder["scene"].add(options["scene"], 'showCompass').listen().name("Compass").onChange(function(val){compass.visible = val; render()});
        //gui.add(options, 'showSun').listen().name("Show sun").onChange(function(val){ noOp() });
        //gui.add(options, 'showFloor').listen().name("Show floor").onChange(function(val){ noOp() });
        //gui.add(armStowFcnWrapper,'add').name("Stow Arm");
        //gui.add(armUnstowFcnWrapper,'add').name("Unstow Arm");

        folder["attitude"] = gui.addFolder('Attitude');
        folder["attitude"].add(options["attitude"], 'roll', -40, 40).listen().name("Roll").onChange(tiltRover);
        folder["attitude"].add(options["attitude"], 'pitch', -40, 40).listen().name("Pitch").onChange(tiltRover);
        folder["attitude"].add(options["attitude"], 'yaw', -370, 370).listen().name("Heading").onChange(changeHeading);
        folder["attitude"].add(options["attitude"], 'height', -3.0, 3.0).listen().name("Height").onChange(liftRover);
        folder["attitude"].add(options["attitude"], 'showRnavCoordFrame').listen().name("Show RNAV").onChange(function(val){
          roverNavCoordFrameAxes.visible = val; 
          render(); 
        });



        // make GUI folder for each joint group:
        jointGroupNames.forEach(function(jointGroupName){
          folder[jointGroupName] = gui.addFolder(jointGroupLongNames[jointGroupName]);
        });

        // make pose selectors:
        jointGroupNames.forEach(function(jointGroupName){          
          folder[jointGroupName].add(options["pose"], jointGroupName, poseNames[jointGroupName]).listen().name("Pose").onChange(function(poseName){goToPose(jointGroupName, poseName)});
        });

        // add joint controls to each joint group folder:
        jointGroupNames.forEach(function(jointGroupName){          
          jointNames[jointGroupName].forEach(function(jointName){
            //console.log(jointName);
            var joint = joints[jointGroupName][jointName];
            joints[jointGroupName][jointName].gui = folder[jointGroupName].add(joint, 'angle', joint.min, joint.max)
              .listen()
              .name(joint.name)
              .onChange(function(val){
                setJoint(jointGroupName, jointName, val); 
                render();
              });
          });
        });
        
        //folder["scene"].open();
        
        // modify differential onchange callback:
        joints["mob"]["diff"].gui.onChange(function(val){ mobSetRockers(val); });

        const loader = new GLTFLoader().setPath( 'model/' );        
        loader.load( 'Perseverance.glb', function ( gltf ) {
          rover = gltf.scene;
          rover.name = "Rover";
          window.rover = rover;
          
          rover.traverse( function ( child ) {
            child.castShadow = true;
            child.receiveShadow = true;
            parts[child.name] = child;
         
            // Check if this is a named joint:
            for(var jointGroupName of jointGroupNames){
              for(var jointName of jointNames[jointGroupName]){
                if(child.name == joints[jointGroupName][jointName].model_obj_name){
                  //console.log("found " + child.name);
                  //console.log(child);
                  joints[jointGroupName][jointName].obj = child;
                  break;
                }
              }
            }
             
            // Make single-sided to avoid rendering artifacts:
            if ( child.isMesh ) {
              child.material.side = THREE.FrontSide;              
            }
          } );
            
          // Replace RMI mirror with mirror object
          rover.getObjectByName("rmi_lens").add( mirrorCamera );
          rmiMirror = rover.getObjectByName("rmi_mirror");
          rmiMirror.material.opacity = 0;
          var mirrorPos = new THREE.Vector3();
          rmiMirror.getWorldPosition(mirrorPos);
          mirror.position.copy(mirrorPos);
          rmiMirror.attach(mirror);
          
          console.log(rover);
          
          // Go to initial poses:
          jointGroupNames.forEach(function(jointGroupName){     
            goToPose(jointGroupName, options["pose"][jointGroupName]);
          });

          tiltRover();

          sun.light.target = rover;

          rover.attach(roverNavCoordFrameAxes);
      
          scene.add(rover);
          render();
        } );


				controls.update();

				window.addEventListener('resize', onWindowResize );
        renderer.domElement.addEventListener('mousedown', handleMouseDown, false );
        renderer.domElement.addEventListener('mouseup', handleMouseUp, false );
        renderer.domElement.addEventListener('click', function(e){checkWhatWasClicked(e, scene.children)}, false );
        window.addEventListener('keypress', checkKeypress, false );
        renderer.domElement.addEventListener('dblclick', doubleClicked, false);

        document.addEventListener('mousemove', function(e){mouse.x = e.clientX; mouse.y = e.clientY;}, false); // cache mouse pos
        window.mouse = mouse;
        
        /* The following prevents browsers from interpreting pinch gestures as global zoom */
        //document.addEventListener('gesturestart',  function(e) { dontZoomWindow(e) });
        //document.addEventListener('gesturechange', function(e) { dontZoomWindow(e) });
        //document.addEventListener('gestureend',    function(e) { dontZoomWindow(e) });
			}


      function dontZoomWindow(event){
        e.preventDefault();
        document.body.style.zoom = 0.99;
      }

      function handleMouseDown(){
				controls.update();
        if(options["tools"].ruler){
          console.log("mouse down at");
          var intersects = checkWhatWasClicked(event, [terrain, rover]);
          //console.log(intersects);
          //console.log(intersects[0].object.type);
          //if(intersects[0].object.type=="Mesh"){
            ruler.line.visible = false;
            ruler.pin1.visible = false;
            ruler.pos0 = intersects[0].point.clone();
            ruler.pin0.position.copy(ruler.pos0);
            ruler.pin0.visible = true;
            render();
          //}
        }
      }
      
      function handleMouseUp(){
        if(options["tools"].ruler){
          console.log("mouse up at");
          var intersects = checkWhatWasClicked(event, [terrain, rover]);
          //console.log(intersects);
          //console.log(intersects[0].object.type);
          //if(intersects[0].object.type=="Mesh"){
            ruler.pos1 = intersects[0].point.clone();
            ruler.pin1.position.copy(ruler.pos1);
            ruler.pin1.visible = true;
            //ruler.line.geometry.setFromPoints([ruler.pin0.children[1].position, ruler.pin1.children[1].position]);
            ruler.line.geometry.setFromPoints([ruler.pos0, ruler.pos1]);
            //ruler.line.geometry.verticesNeedUpdate = true;
            ruler.line.geometry.attributes.position.needsUpdate = true;
            //ruler.line.geometry.computeBoundingSphere();
            ruler.line.frustumCulled = false;
            ruler.line.visible = true;
            render();
            controls.update();
            
            var from1to2 = ruler.pos1.clone().sub(ruler.pos0);
            console.log("Stright-line distance: " + from1to2.length().toPrecision(4) + "m");
            console.log(from1to2);
          //}
        }
      }
      

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
        
				mirror.getRenderTarget().setSize(
					window.innerWidth * window.devicePixelRatio,
					window.innerHeight * window.devicePixelRatio
				);
				render();
			}

			function render() {
				//copy position of the camera into inset
				compassInsetCamera.position.copy(controls.target.clone().sub(camera.position));
				compassInsetCamera.position.setLength(2);
				compassInsetCamera.lookAt(compassInsetScene.position);
				compassInsetRenderer.render(compassInsetScene, compassInsetCamera);
        
        renderer.render( scene, camera );
			}

      function toggleRuler(){
        console.log( (options["tools"].ruler? "enabling" : "disabling") + " ruler");
        if(options["tools"].ruler){
          controls.enabled = false;
        
        } else {
          controls.enabled = true;
        }
      }


			function makeCompass() {
        const radius = 0.75;
      
        // based on: https://threejs.org/examples/#webgl_loader_nrrd
				const compassInsetWidth = 60, compassInsetHeight = 60;
				compassInsetContainer = document.getElementById('compassInset');
				compassInsetContainer.width = compassInsetWidth;
				compassInsetContainer.height = compassInsetHeight;
				compassInsetRenderer = new THREE.WebGLRenderer( { alpha: true } );
				compassInsetRenderer.setClearColor( 0x000000, 0 );
				compassInsetRenderer.setSize( compassInsetWidth, compassInsetHeight );
				compassInsetContainer.appendChild( compassInsetRenderer.domElement );
				compassInsetScene = new THREE.Scene();
        compassInsetCamera = new THREE.OrthographicCamera( 1, -1, 1, -1, 0, 4 );
				compassInsetCamera.up = camera.up; // important!
        compass = new THREE.Group();
        
        const northArrow = new THREE.ArrowHelper(
          new THREE.Vector3(1, 0, 0), //direction
          new THREE.Vector3(-radius, 0, 0), //origin
          2*radius, //length
          0xff0000, //color
          0.2, //head length
          0.2, //head width
        );
        northArrow.line.material.linewidth = 2;
        compass.add(northArrow);
        
        const eastArrow = new THREE.ArrowHelper(
          new THREE.Vector3(0, 1, 0), //direction
          new THREE.Vector3(0, -radius, 0), //origin
          2*radius, //length
          0x00aaff, //color
          0.2, //head length
          0.2, //head width
        );
        eastArrow.line.material.linewidth = 2;
        compass.add(eastArrow);

        // Make Circles:
        var points = [];
        for(let i=0; i<=360; i+=15){
          points.push(new THREE.Vector3(Math.sin(i*(Math.PI/180))*radius, Math.cos(i*(Math.PI/180))*radius, 0));
        }
        var circleGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const circleMaterial = new THREE.MeshBasicMaterial({color: 0x44aaaa, wireframeLinewidth:1, opacity:0.3, transparent: true});
        const circleXY = new THREE.Line(circleGeometry, circleMaterial);
        compass.add( circleXY );
        
        const circleXZ = circleXY.clone();
        circleXZ.rotation.x = Math.PI/2;
        compass.add( circleXZ );
        
        const circleYZ = circleXY.clone();
        circleYZ.rotation.y = Math.PI/2;
        compass.add( circleYZ );
        
        /*
        const eastWestLinePoints = [new THREE.Vector3(0,-radius,0), new THREE.Vector3(0,radius,0)];
        const eastWestLineGeometry = new THREE.BufferGeometry().setFromPoints(eastWestLinePoints);
        const eastWestLineMaterial = new THREE.MeshBasicMaterial({color: 0x004444, linewidth:1, opacity:0.02});
        const eastWestLine = new THREE.Line(eastWestLineGeometry, eastWestLineMaterial);
        compass.add( eastWestLine );
        */
				compassInsetScene.add( compass );
        window.compass = compass;
			}


      function makeTerrain(params){
        if(params.urlHeightMap==undefined) {
          console.log("makeTerrain error: expected urlHeightMap in parameters array");
          return;
        }
        var hscale = (params.hscale==undefined) ? 1 : params.hscale;
        var vscale = (params.vscale==undefined) ? 1 : params.vscale;
        var color  = (params.color==undefined) ? '0x3c332c' : params.color;
        var position = (params.position==undefined) ? new THREE.Vector3(0,0,0) : params.position;

        console.log("loading terrain");
        terrain = new THREE.Mesh();
        terrain.material = new THREE.MeshPhongMaterial({
          color: color,
          shininess: 3,
        });
        window.terrain = terrain;

        terrainWireframe = new THREE.Mesh();
        terrainWireframe.material = new THREE.MeshBasicMaterial({
          color: 0x222222,
          //polygonOffset: true,
          //polygonOffsetFactor: 0.2,
          //polygonOffsetUnits: 1,
          wireframe: true,
        });
        
        console.log("loading height map");
        readTiff(params.urlHeightMap, function(heightMap){

          terrain.geometry = new THREE.PlaneBufferGeometry(heightMap.width*hscale, heightMap.height*hscale, heightMap.width-1, heightMap.height-1);

          if(params.urlTextureMap!==undefined){
            console.log("loading terrain texture..");
            terrain.material.map = new THREE.TextureLoader().load(params.urlTextureMap, function(){console.log("done loading terrain texture")});
            render();
          }

          if(params.urlNormalsMap!==undefined){
            terrain.material.normalMap = new THREE.TextureLoader().load(params.urlNormalsMap);
          }
          
          //set height of vertices:
          const vertices = terrain.geometry.attributes.position;
          for(var i=0; i<vertices.count; i++ ) {
            vertices.setZ(i, heightMap.data[i]*vscale);
          }

          //terrain.geometry.computeVertexNormals();
          terrain.geometry.computeFaceNormals();
          terrain.castShadow = true;
          terrain.receiveShadow = true;
          //terrain.matrixAutoUpdate = false;;
          console.log("done loading terrain");
          
          terrain.hscale = hscale; // not used by 3js; just note for general use elsewhere
          terrain.vscale = vscale; // not used by 3js; just note for general use elsewhere 

          renderer.shadowMap.needsUpdate = true;
          render();
          
          terrainWireframe.geometry = terrain.geometry;
          terrain.attach(terrainWireframe);

          if(params.onload!==undefined) params.onload();

        });
      }
      window.makeTerrain = makeTerrain;


      function goToPose(jointGroup, poseName){
        //console.log("Go to " + jointGroup + " pose: " + poseName);
        var joints = poses[jointGroup][poseName].map(function(angle){return angle*rad2deg});
        //console.log("joints: " + joints);
        setJoints(jointGroup, joints);
        if(jointGroup == "mob") mobSetRockers(0);
      }

      function setJoints(jointGroup, jointAngles){
        //console.log("joint group " + jointGroup);
        var n = 0;
        //console.log(jointNames);
        jointNames[jointGroup].forEach(function(jointName){
          setJoint(jointGroup, jointName, jointAngles[n++]);
        });
        render();
      }
   

      function setJoint(jointGroupName, jointName, angle){
        //console.log(jointGroupName + ", joint " + jointName + ", angle " + angle);
        var joint = joints[jointGroupName][jointName];
        //console.log(joint);
        joint.angle = angle;
        joint.obj.rotation[joint.axis] = joint.dir*angle*deg2rad;
      }


      function mobSetRockers(diffAngle){
        setJoint("mob", "diff", diffAngle); 
        var rocker_angle = diffAngle*2.2 * deg2rad;
        parts["suspension_rocker_right"].rotation.y = rocker_angle;
        parts["suspension_rocker_left"].rotation.y = -1*rocker_angle;
        parts["suspension_diff_link_right"].rotation.y = -1*rocker_angle;
        parts["suspension_diff_link_left"].rotation.y = rocker_angle;
        render();
      }


      function placeSun(){
        var sunX = options["sun"].dist * Math.cos(options["sun"].el * deg2rad) * Math.cos(options["sun"].az * deg2rad) ;
        var sunY = options["sun"].dist * Math.cos(options["sun"].el * deg2rad) * Math.sin(options["sun"].az * deg2rad);
        var sunZ = -1 * options["sun"].dist * Math.sin(Math.max(-0.5,options["sun"].el) * deg2rad);
        sun.pos.set(sunX, sunY, sunZ);
        sun.light.position.set(sunX, sunY, sunZ);
				sky.material.uniforms[ "sunPosition" ].value.copy( sun.pos );
        var intensityMultiplier = 1;
        var sunEl = Math.max(0, options["sun"].el<90? options["sun"].el : 180-options["sun"].el);
        if(sunEl<20){
          // Quadratic extinction
          var intensityMultiplier = sun.light.extinctionCoeffs[0]*sunEl*sunEl + sun.light.extinctionCoeffs[1]*sunEl + sun.light.extinctionCoeffs[2];
        }
        diffuselight.intensity =  options["sky"].initialDiffuseLightIntensity * intensityMultiplier;
        sun.light.intensity =  options["sun"].initialLightIntensity * intensityMultiplier;
        scene.fog.color = new THREE.Color(options["scene"].surfaceColor).multiplyScalar(intensityMultiplier*0.8);
        render();
      }

      function tiltRover(){
        var newAttitude = new THREE.Vector3(
          options["attitude"].roll*deg2rad,
          options["attitude"].pitch*deg2rad, 
          options["attitude"].yaw*deg2rad, 
        );
        //console.log(newAttitude);
        rover.rotation.setFromVector3(newAttitude, 'ZYX');
        render();
      }
      
      function changeHeading(){
        var matrix = new THREE.Matrix4();
        matrix.extractRotation( rover.matrix );
        var roverZ = new THREE.Vector3(0,0,1).transformDirection(matrix);
        settleRover(roverZ.multiplyScalar(-1));
      }
      
      function liftRover(){
        rover.position.z = -1*options["attitude"].height;
        render();
      }



      function createCoordAxes(parent, vector_length, frame_name = "coord_frame"){ 
        const coord_axes = new THREE.Group();
        coord_axes.name = frame_name;

        var geom = new THREE.BufferGeometry().setFromPoints( [new THREE.Vector3(0,0,0), new THREE.Vector3(vector_length,0,0)] );
        var matl = new THREE.LineBasicMaterial({color: 0xff0000, opacity: 0.2});
        var coord_axis = new THREE.Line( geom, matl );
        coord_axes.add(coord_axis);

        var geom = new THREE.BufferGeometry().setFromPoints( [new THREE.Vector3(0,0,0), new THREE.Vector3(0,vector_length,0)] );
        var matl = new THREE.LineBasicMaterial({ 	color: 0x00ff00, opacity: 0.2 });
        var coord_axis = new THREE.Line( geom, matl );
        coord_axes.add(coord_axis);
        
        var geom = new THREE.BufferGeometry().setFromPoints( [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,vector_length)] );
        var matl = new THREE.LineBasicMaterial({ 	color: 0x0000ff, opacity: 0.2 });
        var coord_axis = new THREE.Line( geom, matl );
        coord_axes.add(coord_axis);

        parent.add(coord_axes);
        console.log(coord_axes);
        return coord_axes;
      }
      window.createCoordAxes = createCoordAxes;

      function doubleClicked(event){
        console.log("double clicked");
        var intersects = checkWhatWasClicked(event, [terrain, rover]);
        console.log(intersects[0].point);
        //camera.position.set(intersects[0].point);
        //camera.translate(0,0, -1*camera.position.distanceTo(intersects[0].point));
        moveCameraToViewTarget(intersects[0].point);
      }

      function moveCameraToViewTarget(newTargetPosition){
        var oldCamPos = camera.position.clone();
        var oldTargetPosition = controls.target.clone();
        var vecOldTargetToNewTarget = newTargetPosition.clone().sub(oldTargetPosition);
        /*
        // Animate camera transition (doesn't work)
        var nTransitionFrames = 10;
        for(var i=1; i<=nTransitionFrames; i++){
          camera.position.copy(oldCamPos.clone().add(vecOldTargetToNewTarget.clone().multiplyScalar(i/nTransitionFrames)));
          console.log(camera.position);
          //camera.lookAt(oldTargetPosition.clone().add(vecOldTargetToNewTarget.clone().multiplyScalar(i/nTransitionFrames)));
          controls.target.copy(oldTargetPosition.clone().add(vecOldTargetToNewTarget.clone().multiplyScalar(i/nTransitionFrames)));
          controls.update();
          requestAnimationFrame(render);
          render();
        }
        */
        camera.position.copy(oldCamPos.clone().add(vecOldTargetToNewTarget));
        controls.target.copy(newTargetPosition);
        controls.update();
        render();
      }


      function checkKeypress(event){
        var keyAscii = String.fromCharCode(event.keyCode);
        console.log('key pressed: "' + keyAscii + '" [' + event.keyCode + ']');
        console.log(event);
        var mouseNow = new THREE.Vector2().copy(mouse);
        console.log(mouseNow);
        if(event.key == "Enter") {
          
        } else if(keyAscii) {
          switch (keyAscii) {
            case "d":  console.log("DROP");   dropRover(mouseNow);  break;
            case "r":  console.log("ROVER");  moveCameraToViewTarget(rover.position); break;
            case "t":  console.log("TOP");    break;
            default:   console.log("unhandled key"); 
          }
        } else {
          console.log("unhandled key"); 
        }
      }


      function dropRover( mousecoords ) {
        //var intersects = checkWhatWasClicked(event);
        //console.log(intersects[0].point);
        var mouseCameraCoords = new THREE.Vector2();
        mouseCameraCoords.x = ( mousecoords.x / renderer.domElement.clientWidth ) * 2 - 1;
        mouseCameraCoords.y = - ( mousecoords.y / renderer.domElement.clientHeight ) * 2 + 1;
        raycaster.setFromCamera(mouseCameraCoords, camera);
				var intersects = raycaster.intersectObjects([terrain]);
				if(intersects.length==0) return;
        console.log(intersects[0]);        
        vecs.pos = intersects[0].point;
        rover.position.copy(intersects[0].point);
        
        const normalMatrix = new THREE.Matrix3().getNormalMatrix( intersects[0].object.matrixWorld );        
        vecs.n = intersects[0].face.normal.clone().applyMatrix3( normalMatrix ).normalize();  // normal vector to local terrain
        settleRover(vecs.n);
      }

      function settleRover(roverUpVec){
        // Rotate rover to match local normal vector, preserving heading.
        // Start by calculating local-level heading vector via basic trig in local-level xy plane.
        // There exists a unique vertical plane which contains both our heading vector and the nadir vector,
        // and also the new x vector which we're solving for.  Describe this plane via its normal vector 
        // which we solve for as the cross-product between local-level heading vector and nadir vector.
        // The new X vector must simultaneously exist in the plane orthogonal to the terrain normal vector.
        // Therefore the cross product between the normal vectors defining these two planes describes the
        // intersection of the two planes which includes the new x vector.
        
        var hdg = options["attitude"].yaw*deg2rad;
        vecs.h = new THREE.Vector3(Math.cos(hdg), Math.sin(hdg), 0);  // heading vector in global xy plane
        vecs.nadir = new THREE.Vector3(0, 0, 1);                     // nadir direction (down)
        vecs.nhz  = new THREE.Vector3().crossVectors(vecs.h, vecs.nadir).normalize();  // normal to heading vec and nadir
        vecs.newz = roverUpVec.clone().multiplyScalar(-1);
        vecs.newx = new THREE.Vector3().crossVectors(vecs.newz, vecs.nhz).normalize(); 
        vecs.newy = new THREE.Vector3().crossVectors(vecs.newz, vecs.newx).normalize();
        vecs.zzr  = new THREE.Vector3().crossVectors(vecs.nhz, vecs.newx).normalize(); // where newz would be if zero roll
        var rollsign = vecs.nhz.dot(vecs.newz)>0? 1 : -1;
        var roll = Math.acos(vecs.zzr.clone().dot(vecs.newz))*rollsign;
        console.log("roll: " + roll);
        console.log(vecs);
        
        var pitch = Math.asin(vecs.newx.z*-1);
        console.log("pitch: " + pitch);
        options["attitude"].roll = roll*rad2deg;
        options["attitude"].pitch = pitch*rad2deg;
        tiltRover();
      }



      function checkWhatWasClicked( event, parent ) {
        console.log("clicked:");
        //event.preventDefault();        
        clicked.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        clicked.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
        raycaster.setFromCamera(clicked, camera );
        var intersects = raycaster.intersectObjects(parent, true );
        if(intersects[0].object && intersects[0].object.name) {
          console.log(intersects[0].object.name);
          console.log(intersects[0].object);
        }
        console.log(intersects[0].point);
        window.selected = intersects[0];
        return intersects;
        /*
        // The following are useful when trying to identify specific rover part
        console.log("ancestors:");
        intersects[0].object.traverseAncestors( function ( ancestor ) {
          console.log(ancestor.name);
        });
        console.log("descendents:");
        intersects[0].object.traverse(function(child){
          console.log(child.name);
        });
        */
      }

      function show(object, includeDescendents, doShow){
        object.visible = doShow;
        if(includeDescendents){
          object.traverse(function(child){
            console.log(child.name);
            child.visible = doShow;
          });
        }
        render();
      }
      window.show = show;


      function readTiff(url, onload) {
        var xhr = new XMLHttpRequest();
        console.log("getting tiff file: " + url);
        xhr.open("GET", url);
        //xhr.responseType = "blob";
        xhr.responseType = 'arraybuffer';

        xhr.onload = function (e) {
          if (this.status == 200) {
            console.log(xhr.response);
            console.log("Reading tiff file");
            //var blob = new Blob([xhr.response], {type: "image/tiff"});
            const { width, height, data, ifdEntries } = decode(xhr.response, {singlePage: true, normalizeStripData: false} );
            const metadata = JSON.stringify({ width, height, ifdEntries }, null, 2);
            console.log(metadata);
            if(onload!==undefined) onload({width: width, height: height, data: data});
            return {width: width, height: height, data: data};
          } else {
            console.log("Error, return status: " + this.status);
            console.log(e);
          }
        };
        xhr.onerror = function(e) {
          alert("Error Status: " + e.target.status);
        };
        xhr.send();
      }
  
  
      function makePin(origin, direction, pinLength, pinHeadWidth, pinColor, onload){
        const pin = new THREE.Group();

        // make needle:
        const pinheadPos = direction.normalize().multiplyScalar(pinLength)
        const needleGeometry = new THREE.BufferGeometry().setFromPoints( [origin, pinheadPos] );
        const needleMaterial = new THREE.LineBasicMaterial({color: pinColor});
        const needle = new THREE.Line( needleGeometry, needleMaterial );
        pin.add(needle);
        
        // make pinhead: 
        var pinheadMaterial = new THREE.SpriteMaterial( { 
          map: new THREE.TextureLoader().load('images/poi.png'),
          sizeAttenuation: false, 
          opacity: 0.6,
        });
        var pinheadSprite = new THREE.Sprite(pinheadMaterial);
        pinheadSprite.scale.set(pinHeadWidth, pinHeadWidth, pinHeadWidth);
        pinheadSprite.position.copy(pinheadPos);
        pin.add(pinheadSprite);

        if(onload) onload(pin);
        return pin;
      }
      window.makePin = makePin;
  
  
      function startLoadingManager(){
        const status = document.getElementById('status_container');
        THREE.DefaultLoadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) {
          console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
          status.style.color = "orange";
          status.innerText = "Loading";
        };
        THREE.DefaultLoadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
          console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
        };
        THREE.DefaultLoadingManager.onLoad = function ( ) {
          console.log( 'Loading Complete!');
          status.style.color = "green";
          status.innerText = "Ready";
          render();
        };
      }

		</script>

	</body>
</html>
